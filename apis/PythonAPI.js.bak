class PythonAPI {
    constructor() {
        this.endpoint = 'https://pyright-checker.vercel.app/api/check';
        this.timeout = 5000;
    }

    async testConnection() {
        try {
            const response = await fetch('https://pyright-checker.vercel.app/api/status', {
                method: 'HEAD',
                timeout: 3000
            });
            return response.ok;
        } catch (error) {
            console.log('Python API 连接测试失败，使用本地检查');
            return false;
        }
    }

    async lint(code) {
        // 如果API不可用，直接返回空数组，让本地检查器处理
        if (!await this.testConnection()) {
            return [];
        }

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        
        try {
            const requestBody = {
                code: code,
                options: {
                    typeChecking: true,
                    pythonVersion: '3.8'
                }
            };
            
            const response = await fetch(this.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error();
            }
            
            const result = await response.json();
            return this.transformResponse(result);
            
        } catch (error) {
            clearTimeout(timeoutId);
            if (error.name === 'AbortError') {
                console.warn('Python API请求超时');
            } else {
                console.warn('Python API检查失败:', error.message);
            }
            return []; // 返回空数组，让本地检查器处理
        }
    }

    transformResponse(result) {
        const errors = [];
        
        if (result.diagnostics && Array.isArray(result.diagnostics)) {
            result.diagnostics.forEach(diag => {
                errors.push({
                    line: diag.range?.start?.line || 0,
                    column: diag.range?.start?.character || 0,
                    message: diag.message,
                    severity: this.mapSeverity(diag.severity),
                    source: 'Pyright',
                    rule: diag.rule
                });
            });
        }
        
        return errors;
    }

    mapSeverity(severity) {
        const map = {
            'error': 'error',
            'warning': 'warning', 
            'information': 'info'
        };
        return map[severity] || 'warning';
    }

    // Python 本地检查的辅助方法
    basicPythonCheck(code) {
        const errors = [];
        const lines = code.split('\n');
        
        lines.forEach((line, lineNumber) => {
            // 检查缩进错误（混合空格和制表符）
            if (line.includes('    ') && line.includes('\t')) {
                errors.push({
                    line: lineNumber,
                    column: 0,
                    message: '混合使用制表符和空格进行缩进',
                    severity: 'warning',
                    source: 'Python Local Checker'
                });
            }
            
            // 检查常见的语法问题
            if (line.trim().endsWith(':') && !line.trim().startsWith('#')) {
                // 检查冒号后是否有语句（简单的缩进检查）
                const nextLine = lines[lineNumber + 1];
                if (nextLine && nextLine.trim() !== '') {
                    const expectedIndent = line.search(/\S/);
                    const actualIndent = nextLine.search(/\S/);
                    
                    if (actualIndent <= expectedIndent && actualIndent !== -1) {
                        errors.push({
                            line: lineNumber + 1,
                            column: 0,
                            message: '缩进错误：冒号后的语句应该缩进',
                            severity: 'error',
                            source: 'Python Local Checker'
                        });
                    }
                }
            }
            
            // 检查未闭合的括号
            this.checkUnclosedBrackets(line, lineNumber, errors);
        });
        
        return errors;
    }
    
    checkUnclosedBrackets(line, lineNumber, errors) {
        const brackets = [
            { open: '(', close: ')', name: '圆括号' },
            { open: '[', close: ']', name: '方括号' },
            { open: '{', close: '}', name: '花括号' }
        ];
        
        brackets.forEach(({ open, close, name }) => {
            const openCount = (line.match(new RegExp('\' + open, 'g')) || []).length;
            const closeCount = (line.match(new RegExp('\' + close, 'g')) || []).length;
            
            if (openCount > closeCount) {
                const lastOpenIndex = line.lastIndexOf(open);
                errors.push({
                    line: lineNumber,
                    column: lastOpenIndex,
                    message: ,
                    severity: 'error',
                    source: 'Python Local Checker'
                });
            }
        });
    }
}
